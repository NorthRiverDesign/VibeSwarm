@inject IFileSystemService FileSystemService
@inject IProjectService ProjectService
@inject ISettingsService SettingsService
@inject NavigationManager NavigationManager

<ModalDialog @bind-IsVisible="_isVisible" Title="Scan For Projects" Icon="folder-symlink"
	Size="ModalDialog.ModalSize.Large">
	<ChildContent>
		@if (_isLoading)
		{
			<div class="d-flex justify-content-center align-items-center py-5">
				<div class="spinner-border text-primary" role="status">
					<span class="visually-hidden">Scanning directories...</span>
				</div>
				<span class="ms-3">Scanning directories...</span>
			</div>
		}
		else if (!string.IsNullOrEmpty(_errorMessage))
		{
			<div class="alert alert-danger mb-0">
				<i class="bi bi-exclamation-circle me-2"></i>@_errorMessage
			</div>
		}
		else if (_unmatchedDirectories.Count == 0)
		{
			<div class="text-center py-5 text-muted">
				<i class="bi bi-check-circle fs-1 text-success"></i>
				<p class="mt-3 mb-0">All directories in the projects folder are already imported as projects.</p>
			</div>
		}
		else
		{
			<p class="text-body-secondary mb-3">
				Found <strong>@_unmatchedDirectories.Count</strong> director@(_unmatchedDirectories.Count == 1 ? "y" :
							"ies")
				not matching any existing project. Select directories to import:
			</p>

			<div class="list-group">
				@foreach (var dir in _unmatchedDirectories)
				{
					<label class="list-group-item list-group-item-action d-flex align-items-center gap-3">
						<input type="checkbox" class="form-check-input flex-shrink-0"
							checked="@(_selectedDirectories.Contains(dir.FullPath))"
							@onchange="@((e) => ToggleSelection(dir.FullPath, (bool)(e.Value ?? false)))" />
						<div class="flex-grow-1 min-width-0">
							<div class="d-flex align-items-center gap-2">
								<i class="bi bi-folder-fill text-warning"></i>
								<span class="fw-medium">@dir.Name</span>
								@if (dir.HasGitRepo)
								{
									<span class="badge bg-secondary-subtle text-secondary-emphasis" title="Git repository">
										<i class="bi bi-git me-1"></i>Git
									</span>
								}
							</div>
							<small class="text-muted font-monospace text-truncate d-block">@dir.FullPath</small>
						</div>
					</label>
				}
			</div>

			@if (_selectedDirectories.Count > 0)
			{
				<div class="mt-3 p-3 bg-body-secondary rounded">
					<div class="d-flex align-items-center justify-content-between">
						<span class="text-body-secondary">
							<strong>@_selectedDirectories.Count</strong> director@(_selectedDirectories.Count == 1 ? "y" :
												"ies") selected
						</span>
						<div class="d-flex gap-2">
							<button type="button" class="btn btn-outline-secondary btn-sm" @onclick="ClearSelection">
								Clear
							</button>
							<button type="button" class="btn btn-outline-primary btn-sm" @onclick="SelectAll">
								Select All
							</button>
						</div>
					</div>
				</div>
			}

			@if (_importResults.Count > 0)
			{
				<div class="mt-3">
					<h6 class="text-body-secondary">Import Results:</h6>
					@foreach (var result in _importResults)
					{
						<div class="alert @(result.Success ? "alert-success" : "alert-danger") py-2 mb-2">
							<i class="bi @(result.Success ? "bi-check-circle" : "bi-exclamation-circle") me-2"></i>
							@result.Message
						</div>
					}
				</div>
			}
		}
	</ChildContent>
	<FooterContent>
		<button type="button" class="btn btn-secondary" @onclick="Close">Close</button>
		@if (_unmatchedDirectories.Count > 0 && _selectedDirectories.Count > 0)
		{
			<button type="button" class="btn btn-primary" @onclick="ImportSelected" disabled="@_isImporting">
				@if (_isImporting)
				{
					<span class="spinner-border spinner-border-sm me-1" role="status"></span>
					<span>Importing...</span>
				}
				else
				{
					<i class="bi bi-download me-1"></i>
					<span>Import @_selectedDirectories.Count Project@(_selectedDirectories.Count == 1 ? "" : "s")</span>
				}
			</button>
		}
	</FooterContent>
</ModalDialog>

@code {
	[Parameter]
	public EventCallback OnProjectsImported { get; set; }

	private bool _isVisible = false;
	private bool _isLoading = false;
	private bool _isImporting = false;
	private string? _errorMessage;
	private string _scanPath = "";
	private List<ScannedDirectory> _unmatchedDirectories = new();
	private HashSet<string> _selectedDirectories = new();
	private List<ImportResult> _importResults = new();

	public async Task ShowAsync(string? projectsDirectory = null)
	{
		_isVisible = true;
		_errorMessage = null;
		_unmatchedDirectories.Clear();
		_selectedDirectories.Clear();
		_importResults.Clear();
		StateHasChanged();

		await ScanDirectories(projectsDirectory);
	}

	private async Task ScanDirectories(string? projectsDirectory)
	{
		_isLoading = true;
		StateHasChanged();

		try
		{
			// Get the projects directory from settings if not provided
			if (string.IsNullOrEmpty(projectsDirectory))
			{
				var settings = await SettingsService.GetSettingsAsync();
				projectsDirectory = settings.DefaultProjectsDirectory;
			}

			if (string.IsNullOrEmpty(projectsDirectory))
			{
				_errorMessage = "No projects directory configured. Please set a Default Projects Directory in Settings first.";
				return;
			}

			_scanPath = projectsDirectory;

			// Check if directory exists
			if (!await FileSystemService.DirectoryExistsAsync(projectsDirectory))
			{
				_errorMessage = $"Directory does not exist: {projectsDirectory}";
				return;
			}

			// Get all directories in the projects folder
			var dirResult = await FileSystemService.ListDirectoryAsync(projectsDirectory, directoriesOnly: true);

			if (!string.IsNullOrEmpty(dirResult.Error))
			{
				_errorMessage = dirResult.Error;
				return;
			}

			// Get all existing projects
			var existingProjects = await ProjectService.GetAllAsync();
			var existingPaths = existingProjects
			.Select(p => NormalizePath(p.WorkingPath))
			.ToHashSet(StringComparer.OrdinalIgnoreCase);

			// Find directories that don't match existing projects
			foreach (var entry in dirResult.Entries.Where(e => e.IsDirectory))
			{
				var normalizedPath = NormalizePath(entry.FullPath);
				if (!existingPaths.Contains(normalizedPath))
				{
					_unmatchedDirectories.Add(new ScannedDirectory
					{
						Name = entry.Name,
						FullPath = entry.FullPath,
						HasGitRepo = Directory.Exists(Path.Combine(entry.FullPath, ".git"))
					});
				}
			}

			_unmatchedDirectories = _unmatchedDirectories.OrderBy(d => d.Name).ToList();
		}
		catch (Exception ex)
		{
			_errorMessage = $"Error scanning directories: {ex.Message}";
		}
		finally
		{
			_isLoading = false;
			StateHasChanged();
		}
	}

	private static string NormalizePath(string path)
	{
		// Normalize path for comparison
		return Path.GetFullPath(path).TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
	}

	private void ToggleSelection(string path, bool isChecked)
	{
		if (isChecked)
		{
			_selectedDirectories.Add(path);
		}
		else
		{
			_selectedDirectories.Remove(path);
		}
	}

	private void SelectAll()
	{
		foreach (var dir in _unmatchedDirectories)
		{
			_selectedDirectories.Add(dir.FullPath);
		}
	}

	private void ClearSelection()
	{
		_selectedDirectories.Clear();
	}

	private async Task ImportSelected()
	{
		if (_selectedDirectories.Count == 0) return;

		_isImporting = true;
		_importResults.Clear();
		StateHasChanged();

		try
		{
			foreach (var path in _selectedDirectories.ToList())
			{
				try
				{
					var dirName = Path.GetFileName(path);
					var project = new Project
					{
						Name = dirName,
						WorkingPath = path,
						Description = $"Imported from {_scanPath}"
					};

					await ProjectService.CreateAsync(project);
					_importResults.Add(new ImportResult { Success = true, Message = $"Successfully imported: {dirName}" });

					// Remove from unmatched list
					_unmatchedDirectories.RemoveAll(d => d.FullPath == path);
					_selectedDirectories.Remove(path);
				}
				catch (Exception ex)
				{
					_importResults.Add(new ImportResult { Success = false, Message = $"Failed to import {Path.GetFileName(path)}: {ex.Message}" });
				}
			}

			if (_importResults.Any(r => r.Success))
			{
				await OnProjectsImported.InvokeAsync();
			}
		}
		finally
		{
			_isImporting = false;
			StateHasChanged();
		}
	}

	private void Close()
	{
		_isVisible = false;
	}

	private class ScannedDirectory
	{
		public string Name { get; set; } = string.Empty;
		public string FullPath { get; set; } = string.Empty;
		public bool HasGitRepo { get; set; }
	}

	private class ImportResult
	{
		public bool Success { get; set; }
		public string Message { get; set; } = string.Empty;
	}
}