@page "/projects/{ProjectId:guid}"
@attribute [Authorize]
@inject IProjectService ProjectService
@inject IJobService JobService
@inject IProviderService ProviderService
@inject IVersionControlService VersionControlService
@inject IIdeaService IdeaService
@inject NavigationManager NavigationManager
@inject NotificationService NotificationService
@implements IAsyncDisposable
@using VibeSwarm.Shared.Utilities
@using VibeSwarm.Shared.VersionControl
@using VibeSwarm.Shared.VersionControl.Models
@using Microsoft.AspNetCore.SignalR.Client

@if (IsLoading)
{
    <LoadingSpinner />
}
else if (Project == null)
{
    <Breadcrumb
        Items="@(new List<Breadcrumb.BreadcrumbItem> { new("Projects", "/projects", "folder"), new("Not Found") })" />
    <Alert Type="Alert.AlertType.Warning" Message="Project not found." />
}
else
{
    @* Project Header Component *@
    <ProjectDetailHeaderCompact Name="@Project.Name" WorkingPath="@Project.WorkingPath"
        GitHubRepository="@Project.GitHubRepository" IsGitRepository="@IsGitRepository"
        IsLoadingGitInfo="@_isLoadingGitInfo" Branches="@Branches" CurrentBranch="@CurrentBranch"
        CurrentCommitHash="@CurrentCommitHash" IsGitOperationInProgress="@IsGitOperationInProgress"
        GitOperationMessage="@GitOperationMessage" GitOperationSuccess="@GitOperationSuccess"
        GitProgressMessage="@GitProgressMessage" HasUncommittedChanges="@_hasUncommittedChangesHeader"
        UncommittedFilesCount="@_uncommittedFilesCount" HasTokenData="@HasProjectTokenData()"
        TotalInputTokens="@GetProjectTotalInputTokens()" TotalOutputTokens="@GetProjectTotalOutputTokens()"
        TotalCost="@GetProjectTotalCost()" OnCreateBranch="ShowCreateBranchModal" OnSync="SyncWithOrigin"
        OnRefresh="RefreshBranches" OnBranchSelected="RequestBranchSwitch"
        OnUncommittedChangesClick="ShowUncommittedChangesModal" OnClearGitMessage="ClearGitMessage"
        OnEdit="ShowEditProjectModal" />

    <div class="row g-3">
        @* Ideas Panel on LEFT on desktop for easier access *@
        <div class="col-12 col-xl-5 col-xxl-4 order-1 order-xl-1">
            @* Ideas Panel Component *@
            <IdeasPanel Ideas="@Ideas" CurrentProjectId="@ProjectId" IsProcessingActive="@IsIdeasProcessingActive"
                IsTogglingProcessing="@_isTogglingIdeasProcessing" HasDefaultProvider="@HasDefaultProvider"
                HasActiveJobs="@HasActiveJobs" IsAddingIdea="@_isAddingIdea" ProcessingIdeaIds="@ProcessingIdeaIds"
                OnStartProcessing="StartIdeasProcessing" OnStopProcessing="StopIdeasProcessing" OnAddIdea="AddIdea"
                OnUpdateIdea="UpdateIdea" OnDeleteIdea="DeleteIdea" OnCopyIdea="CopyIdea" OnMoveIdea="MoveIdea"
                OnStartSingleIdea="StartSingleIdea" OnExpandIdea="ExpandIdea" OnApproveExpansion="ApproveIdeaExpansion"
                OnRejectExpansion="RejectIdeaExpansion" />

            @* Git Settings Card *@
            <GitSettingsCard WorkingPath="@Project.WorkingPath" ProjectName="@Project.Name"
                ProjectId="@Project.Id" OnRepositoryCreated="HandleRepositoryCreated" />
        </div>

        @* Jobs list on RIGHT for monitoring progress *@
        <div class="col-12 col-xl-7 col-xxl-8 order-2 order-xl-2">
            <ProjectJobsList Jobs="@Jobs" OnDeleteJob="DeleteJob" OnCreateJob="ShowCreateJobModal" />
        </div>
    </div>

    @if (!string.IsNullOrEmpty(SuccessMessage))
    {
        <Alert Type="Alert.AlertType.Success" Message="@SuccessMessage" Class="mt-3" />
    }

    @* Create Branch Modal *@
    <CreateBranchModal @bind-IsVisible="_showCreateBranchModal" CurrentBranch="@CurrentBranch"
        IsCreating="@_isCreatingBranch" ErrorMessage="@_createBranchError" OnCreate="CreateBranch" />

    @* Branch Switch Confirmation Modal *@
    <BranchSwitchModal @bind-IsVisible="_showBranchSwitchModal" CurrentBranch="@CurrentBranch" TargetBranch="@_targetBranch"
        IsChecking="@_isCheckingUncommittedChanges" IsSwitching="@_isSwitchingBranch"
        HasUncommittedChanges="@_hasUncommittedChanges" ErrorMessage="@_branchSwitchError" OnSwitch="ConfirmBranchSwitch"
        OnCancel="CloseBranchSwitchModal" />

    @* Uncommitted Changes Modal *@
    <UncommittedChangesModal @bind-IsVisible="_showUncommittedChangesModal" IsLoading="@_isLoadingUncommittedDiff"
        ErrorMessage="@_uncommittedDiffError" DiffFiles="@_uncommittedDiffFiles" PendingJobs="@_pendingCommitJobs"
        CommitError="@_uncommittedCommitError" IsCommitting="@_isCommittingChanges" IsDiscarding="@_isDiscardingChanges"
        ShowDiscardConfirmation="@_showDiscardConfirmation" OnCommitAndPush="CommitAndPushUncommittedChanges"
        OnShowDiscard="ShowDiscardConfirmation" OnConfirmDiscard="DiscardAllChanges"
        OnCancelDiscard="CloseDiscardConfirmation" />

    @* Create Job Modal *@
    <CreateJobModal @bind-IsVisible="_showCreateJobModal" JobModel="@NewJob" Providers="@Providers"
        AvailableModels="@AvailableModels" Branches="@Branches" CurrentBranch="@CurrentBranch"
        ShowBranchSelector="@(IsGitRepository && Branches.Any())" IsLoadingModels="@IsLoadingModels" IsSaving="@IsSaving"
        ErrorMessage="@ErrorMessage" SelectedModelId="@SelectedModelId" OnProviderChanged="OnProviderChanged"
        OnSubmit="HandleCreateJob" />

    @* Edit Project Modal *@
    <ProjectModal @bind-IsVisible="_showEditProjectModal" EditProject="@Project" 
        OnSaved="HandleProjectSaved" OnCancelled="HandleProjectModalCancelled" 
        OnClosed="HandleProjectModalClosed" />
}

@code {
    [Parameter]
    public Guid ProjectId { get; set; }

    private Project? Project { get; set; }
    private List<Job> Jobs { get; set; } = new();
    private List<Provider> Providers { get; set; } = new();
    private Job NewJob { get; set; } = new();
    private bool IsLoading { get; set; } = true;
    private bool IsSaving { get; set; }
    private string? ErrorMessage { get; set; }
    private string? SuccessMessage { get; set; }
    private System.Threading.Timer? _refreshTimer;

    // Model selection
    private List<ProviderModel> AvailableModels { get; set; } = new();
    private string SelectedModelId { get; set; } = string.Empty;
    private bool IsLoadingModels { get; set; }

    // Git-related properties
    private bool IsGitRepository { get; set; }
    private bool _isLoadingGitInfo { get; set; } = true; // Start true, will be set false after check
    private List<GitBranchInfo> Branches { get; set; } = new();
    private string? CurrentBranch { get; set; }
    private string? CurrentCommitHash { get; set; }
    private bool IsGitOperationInProgress { get; set; }
    private string? GitOperationMessage { get; set; }
    private bool GitOperationSuccess { get; set; }
    private string? GitProgressMessage { get; set; }

    // Create branch modal state
    private bool _showCreateBranchModal { get; set; }
    private bool _isCreatingBranch { get; set; }
    private string? _createBranchError { get; set; }

    // Create job modal state
    private bool _showCreateJobModal { get; set; }

    // Edit project modal state
    private bool _showEditProjectModal { get; set; }

    // Branch switch confirmation modal state
    private bool _showBranchSwitchModal { get; set; }
    private string? _targetBranch { get; set; }
    private bool _isCheckingUncommittedChanges { get; set; }
    private bool _hasUncommittedChanges { get; set; }
    private bool _isSwitchingBranch { get; set; }
    private string? _branchSwitchError { get; set; }

    // Uncommitted changes modal state
    private bool _hasUncommittedChangesHeader { get; set; }
    private int _uncommittedFilesCount { get; set; }
    private bool _showUncommittedChangesModal { get; set; }
    private bool _isLoadingUncommittedDiff { get; set; }
    private string? _uncommittedDiffError { get; set; }
    private List<DiffFile> _uncommittedDiffFiles { get; set; } = new();
    private List<Job> _pendingCommitJobs { get; set; } = new();
    private string? _uncommittedCommitError { get; set; }
    private bool _isCommittingChanges { get; set; }
    private bool _showDiscardConfirmation { get; set; }
    private bool _isDiscardingChanges { get; set; }

    // Ideas state
    private List<Idea> Ideas { get; set; } = new();
    private bool _isAddingIdea { get; set; }
    private bool IsIdeasProcessingActive { get; set; }
    private bool _isTogglingIdeasProcessing { get; set; }
    private bool HasDefaultProvider => Providers.Any(p => p.IsDefault && p.IsEnabled);
    private HashSet<Guid> ProcessingIdeaIds { get; set; } = new();

    private bool HasActiveJobs => Jobs.Any(j =>
    j.Status == JobStatus.New ||
    j.Status == JobStatus.Pending ||
    j.Status == JobStatus.Started ||
    j.Status == JobStatus.Processing);

    // SignalR connection
    private HubConnection? _hubConnection;
    private bool _signalRConnected;
    private CancellationTokenSource? _signalRCts;

    protected override async Task OnInitializedAsync()
    {
        // Load data first - this controls the loading spinner
        await LoadData();

        // These operations run after loading completes and shouldn't block UI
        // Use fire-and-forget pattern with error handling for non-critical operations
        _ = LoadGitInfoSafe();
        _ = InitializeSignalRSafe();
        StartAutoRefresh();
    }

    /// <summary>
    /// Safe wrapper for LoadGitInfo that won't crash the component
    /// </summary>
    private async Task LoadGitInfoSafe()
    {
        try
        {
            await LoadGitInfo();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Git info load failed (non-critical): {ex.Message}");
            _isLoadingGitInfo = false;
            IsGitRepository = false;
        }
        finally
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>
    /// Safe wrapper for SignalR initialization with timeout and error handling.
    /// SignalR is a progressive enhancement - the app works without it via polling.
    /// </summary>
    private async Task InitializeSignalRSafe()
    {
        try
        {
            _signalRCts = new CancellationTokenSource();

            // Give SignalR 10 seconds to connect on mobile, then fall back to polling
            using var timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(10));
            using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _signalRCts.Token, timeoutCts.Token);

            await InitializeSignalR(linkedCts.Token);
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("SignalR connection timed out - falling back to polling");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SignalR initialization failed (non-critical): {ex.Message}");
        }
    }

    private async Task InitializeSignalR(CancellationToken cancellationToken)
    {
        _hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/job"))
        .WithAutomaticReconnect(new[] { TimeSpan.Zero, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(5),
TimeSpan.FromSeconds(10) })
        .Build();

        // Register all event handlers before connecting
        RegisterSignalRHandlers();

        // Handle connection state changes
        _hubConnection.Closed += async (error) =>
        {
            _signalRConnected = false;
            Console.WriteLine($"SignalR connection closed: {error?.Message ?? "No error"}");
            await Task.CompletedTask;
        };

        _hubConnection.Reconnected += async (connectionId) =>
        {
            _signalRConnected = true;
            Console.WriteLine($"SignalR reconnected: {connectionId}");
            // Re-subscribe after reconnection
            await SubscribeToSignalRGroups();
        };

        try
        {
            await _hubConnection.StartAsync(cancellationToken);
            _signalRConnected = true;
            Console.WriteLine("SignalR connected successfully");
            await SubscribeToSignalRGroups();
        }
        catch (Exception ex) when (ex is not OperationCanceledException)
        {
            Console.WriteLine($"SignalR connection failed: {ex.Message}");
            _signalRConnected = false;
        }
    }

    private void RegisterSignalRHandlers()
    {
        if (_hubConnection == null) return;

        // Listen for job updates (status changes sent as jobId, status)
        _hubConnection.On<string, string>("JobStatusChanged", async (jobId, status) =>
        {
            await InvokeAsync(async () =>
    {
            await RefreshJobs();
            await LoadIdeas();
            StateHasChanged();
        });
        });

        // Job created events include jobId and projectId
        _hubConnection.On<string, string>("JobCreated", async (jobId, projectId) =>
        {
            await InvokeAsync(async () =>
    {
            await RefreshJobs();
            await LoadIdeas();
            StateHasChanged();
        });
        });

        // Job deleted events include jobId and projectId
        _hubConnection.On<string, string>("JobDeleted", async (jobId, projectId) =>
        {
            await InvokeAsync(async () =>
    {
            await RefreshJobs();
            StateHasChanged();
        });
        });

        // Activity updates include jobId, activity, and timestamp
        _hubConnection.On<string, string, DateTime>("JobActivityUpdated", async (jobId, activity, timestamp) =>
        {
            await InvokeAsync(() =>
    {
            var job = Jobs.FirstOrDefault(j => j.Id.ToString() == jobId);
            if (job != null)
            {
                job.CurrentActivity = activity;
                StateHasChanged();
            }
            return Task.CompletedTask;
        });
        });

        // Job completed events
        _hubConnection.On<string, bool, string?>("JobCompleted", async (jobId, success, errorMessage) =>
        {
            await InvokeAsync(async () =>
    {
        // Check if this job was from an idea before refreshing
            var completedJob = Jobs.FirstOrDefault(j => j.Id.ToString() == jobId);
            var wasFromIdea = Ideas.Any(i => i.JobId.ToString() == jobId);

            await RefreshJobs();
            await LoadIdeas();
            await RefreshUncommittedChangesStatus();
            ProcessingIdeaIds.Clear(); // Clear any stale processing states

        // Show toast notification for job completion
            if (completedJob != null)
            {
                var jobTitle = completedJob.Title ?? "Job";
                if (success)
                {
                    NotificationService.ShowSuccess(
            $"{TruncateForToast(jobTitle)} completed successfully.",
            wasFromIdea ? "Idea Completed" : "Job Completed");
                }
                else
                {
                    NotificationService.ShowError(
            errorMessage ?? $"{TruncateForToast(jobTitle)} failed.",
            wasFromIdea ? "Idea Failed" : "Job Failed");
                }
            }

            StateHasChanged();
        });
        });

        // Idea started processing (converted to job) - another user clicked Start
        _hubConnection.On<string, string, string>("IdeaStarted", async (ideaId, projectId, jobId) =>
        {
            await InvokeAsync(async () =>
    {
        // Only refresh if this is for our project
            if (projectId == ProjectId.ToString())
            {
            // Update local state immediately
                if (Guid.TryParse(ideaId, out var ideaGuid))
                {
                    ProcessingIdeaIds.Add(ideaGuid);
                }
                await RefreshJobs();
                await LoadIdeas();
                StateHasChanged();
            }
        });
        });

        // Ideas auto-processing state changed
        _hubConnection.On<string, bool>("IdeasProcessingStateChanged", async (projectId, isActive) =>
        {
            await InvokeAsync(async () =>
    {
        // Only update if this is for our project
            if (projectId == ProjectId.ToString())
            {
                IsIdeasProcessingActive = isActive;
                if (!isActive)
                {
                    ProcessingIdeaIds.Clear();
                }
                await LoadIdeas();
                StateHasChanged();
            }
        });
        });

        // Idea created - another user added an idea
        _hubConnection.On<string, string>("IdeaCreated", async (ideaId, projectId) =>
        {
            await InvokeAsync(async () =>
    {
            if (projectId == ProjectId.ToString())
            {
                await LoadIdeas();
                StateHasChanged();
            }
        });
        });

        // Idea deleted - another user deleted an idea
        _hubConnection.On<string, string>("IdeaDeleted", async (ideaId, projectId) =>
        {
            await InvokeAsync(async () =>
    {
            if (projectId == ProjectId.ToString())
            {
            // Remove from local processing set if present
                if (Guid.TryParse(ideaId, out var ideaGuid))
                {
                    ProcessingIdeaIds.Remove(ideaGuid);
                }
                await LoadIdeas();
                StateHasChanged();
            }
        });
        });

        // Idea updated - another user edited/expanded an idea
        _hubConnection.On<string, string>("IdeaUpdated", async (ideaId, projectId) =>
        {
            await InvokeAsync(async () =>
    {
            if (projectId == ProjectId.ToString())
            {
                await LoadIdeas();
                StateHasChanged();
            }
        });
        });
    }

    private async Task SubscribeToSignalRGroups()
    {
        if (_hubConnection?.State != HubConnectionState.Connected) return;

        try
        {
            // Subscribe to both project-specific and global job list updates for complete coverage
            await _hubConnection.InvokeAsync("SubscribeToProject", ProjectId.ToString());
            await _hubConnection.InvokeAsync("SubscribeToJobList");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SignalR subscription failed: {ex.Message}");
        }
    }

    private void StartAutoRefresh()
    {
        _refreshTimer = new System.Threading.Timer(async _ =>
        {
            if (HasActiveJobs || IsIdeasProcessingActive)
            {
                await InvokeAsync(async () =>
        {
            await RefreshJobs();
            await LoadIdeas();
            StateHasChanged();
        });
            }
        }, null, TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(3));
    }

    private async Task RefreshJobs()
    {
        if (Project != null)
        {
            Jobs = (await JobService.GetByProjectIdAsync(ProjectId)).ToList();
        }
    }

    private async Task LoadData()
    {
        IsLoading = true;
        try
        {
            Project = await ProjectService.GetByIdAsync(ProjectId);
            if (Project != null)
            {
                Jobs = (await JobService.GetByProjectIdAsync(ProjectId)).ToList();
                await LoadIdeas();
            }
            Providers = (await ProviderService.GetAllAsync()).ToList();

            var defaultProvider = await ProviderService.GetDefaultAsync();
            if (defaultProvider != null)
            {
                NewJob.ProviderId = defaultProvider.Id;
                await LoadModelsForProvider(defaultProvider.Id);
            }
        }
        finally
        {
            IsLoading = false;
        }
    }

    private async Task LoadIdeas()
    {
        Ideas = (await IdeaService.GetByProjectIdAsync(ProjectId)).ToList();
        IsIdeasProcessingActive = await IdeaService.IsProcessingActiveAsync(ProjectId);
    }

    private async Task LoadGitInfo()
    {
        if (Project == null || string.IsNullOrEmpty(Project.WorkingPath))
        {
            _isLoadingGitInfo = false;
            return;
        }

        _isLoadingGitInfo = true;

        try
        {
            IsGitRepository = await VersionControlService.IsGitRepositoryAsync(Project.WorkingPath);
            Console.WriteLine($"IsGitRepositoryAsync returned: {IsGitRepository} for path: {Project.WorkingPath}");

            if (IsGitRepository)
            {
                CurrentBranch = await VersionControlService.GetCurrentBranchAsync(Project.WorkingPath);
                CurrentCommitHash = await VersionControlService.GetCurrentCommitHashAsync(Project.WorkingPath);
                Console.WriteLine($"Git info: Branch={CurrentBranch}, Commit={CurrentCommitHash}");
                NewJob.Branch = CurrentBranch;
                await LoadBranches();
                Console.WriteLine($"Loaded {Branches.Count} branches");
                await RefreshUncommittedChangesStatus();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"LoadGitInfo error: {ex.Message}");
            IsGitRepository = false;
        }
        finally
        {
            _isLoadingGitInfo = false;
        }
    }

    private async Task RefreshUncommittedChangesStatus()
    {
        if (Project == null || string.IsNullOrEmpty(Project.WorkingPath) || !IsGitRepository)
            return;

        try
        {
            _hasUncommittedChangesHeader = await VersionControlService.HasUncommittedChangesAsync(Project.WorkingPath);
            if (_hasUncommittedChangesHeader)
            {
                // Use GetChangedFilesAsync which returns a proper list of changed files
                var changedFiles = await VersionControlService.GetChangedFilesAsync(Project.WorkingPath);
                _uncommittedFilesCount = changedFiles.Count;
                if (_uncommittedFilesCount == 0) _uncommittedFilesCount = 1; // At least 1 if HasUncommittedChanges is true
            }
            else
            {
                _uncommittedFilesCount = 0;
            }
        }
        catch
        {
            _hasUncommittedChangesHeader = false;
            _uncommittedFilesCount = 0;
        }
    }

    private async Task LoadBranches()
    {
        if (Project == null || string.IsNullOrEmpty(Project.WorkingPath))
            return;

        try
        {
            Branches = (await VersionControlService.GetBranchesAsync(Project.WorkingPath, includeRemote: true)).ToList();
        }
        catch
        {
            Branches = new List<GitBranchInfo>();
        }
    }

    private async Task RefreshBranches()
    {
        if (IsGitOperationInProgress) return;

        IsGitOperationInProgress = true;
        GitProgressMessage = "Fetching latest branches...";
        StateHasChanged();

        try
        {
            if (Project != null && !string.IsNullOrEmpty(Project.WorkingPath))
            {
                await VersionControlService.FetchAsync(Project.WorkingPath);
                await LoadBranches();
                CurrentBranch = await VersionControlService.GetCurrentBranchAsync(Project.WorkingPath);
                CurrentCommitHash = await VersionControlService.GetCurrentCommitHashAsync(Project.WorkingPath);
            }
        }
        catch (Exception ex)
        {
            GitOperationMessage = $"Failed to refresh branches: {ex.Message}";
            GitOperationSuccess = false;
        }
        finally
        {
            IsGitOperationInProgress = false;
            GitProgressMessage = null;
            StateHasChanged();
        }
    }

    private async Task RequestBranchSwitch(string targetBranch)
    {
        if (string.IsNullOrEmpty(targetBranch) || targetBranch == CurrentBranch)
            return;

        _targetBranch = targetBranch;
        _showBranchSwitchModal = true;
        _branchSwitchError = null;
        _isCheckingUncommittedChanges = true;
        _hasUncommittedChanges = false;
        StateHasChanged();

        if (Project != null && !string.IsNullOrEmpty(Project.WorkingPath))
        {
            try
            {
                _hasUncommittedChanges = await VersionControlService.HasUncommittedChangesAsync(Project.WorkingPath);
            }
            catch
            {
                _hasUncommittedChanges = false;
            }
        }

        _isCheckingUncommittedChanges = false;
        StateHasChanged();
    }

    private void CloseBranchSwitchModal()
    {
        _showBranchSwitchModal = false;
        _targetBranch = null;
        _branchSwitchError = null;
    }

    private async Task ConfirmBranchSwitch((bool commitFirst, string? commitMessage) args)
    {
        if (string.IsNullOrEmpty(_targetBranch) || _targetBranch == CurrentBranch)
            return;

        if (Project == null || string.IsNullOrEmpty(Project.WorkingPath))
            return;

        _isSwitchingBranch = true;
        _branchSwitchError = null;
        StateHasChanged();

        try
        {
            if (args.commitFirst && _hasUncommittedChanges && !string.IsNullOrWhiteSpace(args.commitMessage))
            {
                var commitResult = await VersionControlService.CommitAllChangesAsync(
                Project.WorkingPath,
                args.commitMessage.Trim());

                if (!commitResult.Success)
                {
                    _branchSwitchError = $"Failed to commit changes: {commitResult.Error}";
                    _isSwitchingBranch = false;
                    StateHasChanged();
                    return;
                }
            }

            var result = await VersionControlService.HardCheckoutBranchAsync(
            Project.WorkingPath,
            _targetBranch,
            progressCallback: progress =>
            {
                GitProgressMessage = progress;
                InvokeAsync(StateHasChanged);
            });

            if (result.Success)
            {
                GitOperationMessage = $"Successfully switched to branch '{_targetBranch}'";
                GitOperationSuccess = true;
                CurrentBranch = _targetBranch;
                CurrentCommitHash = result.CommitHash;
                await LoadBranches();
                CloseBranchSwitchModal();
            }
            else
            {
                _branchSwitchError = result.Error ?? "Failed to switch branch";
            }
        }
        catch (Exception ex)
        {
            _branchSwitchError = $"Error switching branch: {ex.Message}";
        }
        finally
        {
            _isSwitchingBranch = false;
            GitProgressMessage = null;
            StateHasChanged();
        }
    }

    private async Task SyncWithOrigin()
    {
        if (IsGitOperationInProgress) return;
        if (Project == null || string.IsNullOrEmpty(Project.WorkingPath)) return;

        IsGitOperationInProgress = true;
        GitOperationMessage = null;
        StateHasChanged();

        try
        {
            var result = await VersionControlService.SyncWithOriginAsync(
            Project.WorkingPath,
            progressCallback: progress =>
            {
                GitProgressMessage = progress;
                InvokeAsync(StateHasChanged);
            });

            if (result.Success)
            {
                GitOperationMessage = $"Successfully synced with origin/{CurrentBranch}";
                GitOperationSuccess = true;
                CurrentCommitHash = result.CommitHash;
                await PopulateGitHubRepositoryIfMissing();
            }
            else
            {
                GitOperationMessage = result.Error ?? "Failed to sync with origin";
                GitOperationSuccess = false;
            }
        }
        catch (Exception ex)
        {
            GitOperationMessage = $"Error syncing with origin: {ex.Message}";
            GitOperationSuccess = false;
        }
        finally
        {
            IsGitOperationInProgress = false;
            GitProgressMessage = null;
            StateHasChanged();
        }
    }

    private async Task PopulateGitHubRepositoryIfMissing()
    {
        if (Project == null || string.IsNullOrEmpty(Project.WorkingPath)) return;
        if (!string.IsNullOrWhiteSpace(Project.GitHubRepository)) return;

        try
        {
            var remoteUrl = await VersionControlService.GetRemoteUrlAsync(Project.WorkingPath);
            if (string.IsNullOrWhiteSpace(remoteUrl)) return;

            var gitHubRepo = VersionControlService.ExtractGitHubRepository(remoteUrl);
            if (string.IsNullOrWhiteSpace(gitHubRepo)) return;

            Project.GitHubRepository = gitHubRepo;
            await ProjectService.UpdateAsync(Project);
        }
        catch { }
    }

    private void ClearGitMessage()
    {
        GitOperationMessage = null;
        StateHasChanged();
    }

    private void ShowCreateBranchModal()
    {
        _showCreateBranchModal = true;
        _createBranchError = null;
    }

    private void ShowCreateJobModal()
    {
        // Reset the form for a new job
        NewJob = new Job();
        NewJob.Branch = CurrentBranch;

        // Set default provider if available
        var defaultProvider = Providers.FirstOrDefault(p => p.IsDefault && p.IsEnabled);
        if (defaultProvider != null)
        {
            NewJob.ProviderId = defaultProvider.Id;
            _ = LoadModelsForProvider(defaultProvider.Id);
        }

        ErrorMessage = null;
        _showCreateJobModal = true;
    }

    private void ShowEditProjectModal()
    {
        _showEditProjectModal = true;
    }

    private async Task HandleProjectSaved(Guid? projectId)
    {
        _showEditProjectModal = false;
        // Reload project data to reflect changes
        await LoadData();
        await NotificationService.ShowSuccessAsync("Project updated successfully.");
    }

    private void HandleProjectModalCancelled()
    {
        _showEditProjectModal = false;
    }

    private void HandleProjectModalClosed()
    {
        _showEditProjectModal = false;
    }

    private async Task HandleRepositoryCreated(string? gitHubRepository)
    {
        // Reload data after a repository is created (this updates Project.GitHubRepository in UI)
        await LoadData();
        await LoadGitInfo();
        await NotificationService.ShowSuccessAsync("GitHub repository created and linked successfully!");
    }

    private async Task CreateBranch(string branchName)
    {
        if (string.IsNullOrWhiteSpace(branchName)) return;
        if (Project == null || string.IsNullOrEmpty(Project.WorkingPath)) return;

        _isCreatingBranch = true;
        _createBranchError = null;
        StateHasChanged();

        try
        {
            var result = await VersionControlService.CreateBranchAsync(
            Project.WorkingPath,
            branchName.Trim(),
            switchToBranch: true);

            if (result.Success)
            {
                GitOperationMessage = $"Successfully created and switched to branch '{branchName.Trim()}'";
                GitOperationSuccess = true;
                CurrentBranch = branchName.Trim();
                CurrentCommitHash = result.CommitHash;
                await LoadBranches();
                _showCreateBranchModal = false;
            }
            else
            {
                _createBranchError = result.Error ?? "Failed to create branch";
            }
        }
        catch (Exception ex)
        {
            _createBranchError = $"Error creating branch: {ex.Message}";
        }
        finally
        {
            _isCreatingBranch = false;
            StateHasChanged();
        }
    }

    private async Task OnProviderChanged(Guid providerId)
    {
        NewJob.ProviderId = providerId;
        SelectedModelId = string.Empty;
        AvailableModels.Clear();

        if (providerId != Guid.Empty)
        {
            await LoadModelsForProvider(providerId);
        }
    }

    private async Task LoadModelsForProvider(Guid providerId)
    {
        IsLoadingModels = true;
        try
        {
            AvailableModels = (await ProviderService.GetModelsAsync(providerId)).ToList();

            var lastUsedModel = await JobService.GetLastUsedModelAsync(ProjectId, providerId);
            if (!string.IsNullOrEmpty(lastUsedModel) && AvailableModels.Any(m => m.ModelId == lastUsedModel))
            {
                SelectedModelId = lastUsedModel;
            }
            else
            {
                var defaultModel = AvailableModels.FirstOrDefault(m => m.IsDefault && m.IsAvailable);
                SelectedModelId = defaultModel?.ModelId ?? string.Empty;
            }
        }
        finally
        {
            IsLoadingModels = false;
        }
    }

    private async Task HandleCreateJob()
    {
        if (NewJob.ProviderId == Guid.Empty)
        {
            ErrorMessage = "Please select a provider.";
            return;
        }

        IsSaving = true;
        ErrorMessage = null;
        SuccessMessage = null;

        try
        {
            NewJob.ProjectId = ProjectId;
            NewJob.ModelUsed = string.IsNullOrEmpty(SelectedModelId) ? null : SelectedModelId;
            // For manual jobs, use the goal prompt as the title
            NewJob.Title = NewJob.GoalPrompt;
            var createdJob = await JobService.CreateAsync(NewJob);
            NavigationManager.NavigateTo($"/jobs/view/{createdJob.Id}");
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error creating job: {ex.Message}";
            IsSaving = false;
        }
    }

    private async Task DeleteJob(Guid jobId)
    {
        try
        {
            await JobService.DeleteAsync(jobId);
            Jobs = (await JobService.GetByProjectIdAsync(ProjectId)).ToList();
            SuccessMessage = "Job deleted successfully.";
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error deleting job: {ex.Message}";
        }
    }

    private int GetProjectTotalInputTokens() => Jobs.Sum(j => j.InputTokens ?? 0);
    private int GetProjectTotalOutputTokens() => Jobs.Sum(j => j.OutputTokens ?? 0);
    private decimal GetProjectTotalCost() => Jobs.Sum(j => j.TotalCostUsd ?? 0);
    private bool HasProjectTokenData() => GetProjectTotalInputTokens() > 0 || GetProjectTotalOutputTokens() > 0 ||
    GetProjectTotalCost() > 0;

    private static string TruncateForToast(string text, int maxLength = 50)
    {
        if (string.IsNullOrEmpty(text) || text.Length <= maxLength)
            return text;
        return text[..(maxLength - 3)] + "...";
    }

    // Uncommitted changes modal methods
    private async Task ShowUncommittedChangesModal()
    {
        _showUncommittedChangesModal = true;
        _uncommittedDiffError = null;
        _uncommittedDiffFiles = new List<DiffFile>();
        _pendingCommitJobs = new List<Job>();
        _isLoadingUncommittedDiff = true;
        StateHasChanged();

        if (Project == null || string.IsNullOrEmpty(Project.WorkingPath))
        {
            _uncommittedDiffError = "Project path not available";
            _isLoadingUncommittedDiff = false;
            StateHasChanged();
            return;
        }

        try
        {
            var diffOutput = await VersionControlService.GetWorkingDirectoryDiffAsync(Project.WorkingPath);
            if (!string.IsNullOrEmpty(diffOutput))
            {
                _uncommittedDiffFiles = ParseGitDiff(diffOutput);
            }
            else
            {
                _uncommittedDiffError = "No uncommitted changes found";
            }

            // Load completed jobs without a commit hash (pending attribution)
            _pendingCommitJobs = Jobs
            .Where(j => j.Status == JobStatus.Completed && string.IsNullOrEmpty(j.GitCommitHash))
            .OrderByDescending(j => j.CompletedAt ?? j.StartedAt)
            .ToList();
        }
        catch (Exception ex)
        {
            _uncommittedDiffError = $"Failed to load diff: {ex.Message}";
        }
        finally
        {
            _isLoadingUncommittedDiff = false;
            StateHasChanged();
        }
    }

    private async Task CommitAndPushUncommittedChanges(string commitMessage)
    {
        if (string.IsNullOrWhiteSpace(commitMessage)) return;
        if (Project == null || string.IsNullOrEmpty(Project.WorkingPath)) return;

        _isCommittingChanges = true;
        _uncommittedCommitError = null;
        StateHasChanged();

        try
        {
            var commitResult = await VersionControlService.CommitAllChangesAsync(
            Project.WorkingPath,
            commitMessage.Trim());

            if (!commitResult.Success)
            {
                _uncommittedCommitError = $"Failed to commit: {commitResult.Error}";
                return;
            }

            // Update pending jobs with the commit hash
            if (!string.IsNullOrEmpty(commitResult.CommitHash) && _pendingCommitJobs.Any())
            {
                foreach (var job in _pendingCommitJobs)
                {
                    await JobService.UpdateGitCommitHashAsync(job.Id, commitResult.CommitHash);
                    // Update local cache
                    var localJob = Jobs.FirstOrDefault(j => j.Id == job.Id);
                    if (localJob != null)
                    {
                        localJob.GitCommitHash = commitResult.CommitHash;
                    }
                }
            }

            var pushResult = await VersionControlService.PushAsync(Project.WorkingPath);

            if (pushResult.Success)
            {
                var jobCount = _pendingCommitJobs.Count;
                GitOperationMessage = jobCount > 0
                ? $"Successfully committed and pushed changes. {jobCount} job(s) linked to commit."
                : "Successfully committed and pushed changes";
                GitOperationSuccess = true;
                CurrentCommitHash = commitResult.CommitHash;
                _showUncommittedChangesModal = false;
                await RefreshUncommittedChangesStatus();
            }
            else
            {
                GitOperationMessage = $"Changes committed but push failed: {pushResult.Error}";
                GitOperationSuccess = false;
                _showUncommittedChangesModal = false;
                await RefreshUncommittedChangesStatus();
            }
        }
        catch (Exception ex)
        {
            _uncommittedCommitError = $"Error: {ex.Message}";
        }
        finally
        {
            _isCommittingChanges = false;
            StateHasChanged();
        }
    }

    private void ShowDiscardConfirmation()
    {
        _showDiscardConfirmation = true;
    }

    private void CloseDiscardConfirmation()
    {
        _showDiscardConfirmation = false;
    }

    private async Task DiscardAllChanges()
    {
        if (Project == null || string.IsNullOrEmpty(Project.WorkingPath)) return;

        _isDiscardingChanges = true;
        StateHasChanged();

        try
        {
            var result = await VersionControlService.DiscardAllChangesAsync(Project.WorkingPath);

            if (result.Success)
            {
                GitOperationMessage = "Successfully discarded all uncommitted changes";
                GitOperationSuccess = true;
                _showDiscardConfirmation = false;
                _showUncommittedChangesModal = false;
                await RefreshUncommittedChangesStatus();
            }
            else
            {
                GitOperationMessage = $"Failed to discard changes: {result.Error}";
                GitOperationSuccess = false;
                _showDiscardConfirmation = false;
            }
        }
        catch (Exception ex)
        {
            GitOperationMessage = $"Error discarding changes: {ex.Message}";
            GitOperationSuccess = false;
            _showDiscardConfirmation = false;
        }
        finally
        {
            _isDiscardingChanges = false;
            StateHasChanged();
        }
    }

    private List<DiffFile> ParseGitDiff(string diffOutput)
    {
        return GitDiffParser.ParseDiff(diffOutput);
    }

    // Ideas management methods
    private async Task AddIdea(string description)
    {
        if (string.IsNullOrWhiteSpace(description)) return;

        _isAddingIdea = true;
        StateHasChanged();

        try
        {
            var idea = new Idea
            {
                ProjectId = ProjectId,
                Description = description.Trim()
            };

            await IdeaService.CreateAsync(idea);
            await LoadIdeas();
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error adding idea: {ex.Message}";
        }
        finally
        {
            _isAddingIdea = false;
            StateHasChanged();
        }
    }

    private async Task UpdateIdea(Idea idea)
    {
        try
        {
            await IdeaService.UpdateAsync(idea);
            await LoadIdeas();
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error updating idea: {ex.Message}";
        }
    }

    private async Task DeleteIdea(Guid ideaId)
    {
        try
        {
            await IdeaService.DeleteAsync(ideaId);
            await LoadIdeas();
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error deleting idea: {ex.Message}";
        }
    }

    private async Task CopyIdea((Guid ideaId, Guid targetProjectId) args)
    {
        try
        {
            var targetProject = await ProjectService.GetByIdAsync(args.targetProjectId);
            await IdeaService.CopyToProjectAsync(args.ideaId, args.targetProjectId);
            SuccessMessage = $"Idea copied to {targetProject?.Name ?? "project"} successfully.";
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error copying idea: {ex.Message}";
        }
    }

    private async Task MoveIdea((Guid ideaId, Guid targetProjectId) args)
    {
        try
        {
            var targetProject = await ProjectService.GetByIdAsync(args.targetProjectId);
            await IdeaService.MoveToProjectAsync(args.ideaId, args.targetProjectId);
            await LoadIdeas();
            SuccessMessage = $"Idea moved to {targetProject?.Name ?? "project"} successfully.";
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error moving idea: {ex.Message}";
        }
    }

	private async Task StartIdeasProcessing(bool autoCommit)
	{
		_isTogglingIdeasProcessing = true;
		// Mark all unprocessed ideas as processing immediately for UI feedback
		foreach (var idea in Ideas.Where(i => !i.IsProcessing && !i.JobId.HasValue))
		{
			ProcessingIdeaIds.Add(idea.Id);
		}
		StateHasChanged();

		try
		{
			await IdeaService.StartProcessingAsync(ProjectId, autoCommit);
			IsIdeasProcessingActive = true;
			var commitMessage = autoCommit ? " Auto-commit is enabled." : "";
			NotificationService.ShowInfo($"Ideas will be converted to jobs automatically.{commitMessage}", "Auto-Processing Started");
		}
		catch (Exception ex)
		{
			// Clear processing state on error
			ProcessingIdeaIds.Clear();
			NotificationService.ShowError($"Error starting Ideas processing: {ex.Message}");
		}
		finally
		{
			_isTogglingIdeasProcessing = false;
			StateHasChanged();
		}
	}

    private async Task StopIdeasProcessing()
    {
        _isTogglingIdeasProcessing = true;
        StateHasChanged();

        try
        {
            await IdeaService.StopProcessingAsync(ProjectId);
            IsIdeasProcessingActive = false;
            ProcessingIdeaIds.Clear();
            NotificationService.ShowInfo("Ideas auto-processing stopped.", "Processing Stopped");
        }
        catch (Exception ex)
        {
            NotificationService.ShowError($"Error stopping Ideas processing: {ex.Message}");
        }
        finally
        {
            _isTogglingIdeasProcessing = false;
            StateHasChanged();
        }
    }

    private async Task StartSingleIdea(Guid ideaId)
    {
        // Prevent double-add by checking if already processing
        var idea = Ideas.FirstOrDefault(i => i.Id == ideaId);
        if (idea == null || idea.JobId.HasValue || idea.IsProcessing || ProcessingIdeaIds.Contains(ideaId))
        {
            NotificationService.ShowWarning("This idea is already being processed.");
            return;
        }

        // Mark as processing immediately for UI feedback
        ProcessingIdeaIds.Add(ideaId);
        StateHasChanged();

        try
        {
            var job = await IdeaService.ConvertToJobAsync(ideaId);
            if (job != null)
            {
                await RefreshJobs();
                await LoadIdeas();
                NotificationService.ShowSuccess($"Idea queued as job successfully.", "Idea Started");
            }
            else
            {
                ProcessingIdeaIds.Remove(ideaId);
                NotificationService.ShowError("Failed to convert idea to job.");
            }
        }
        catch (Exception ex)
        {
            ProcessingIdeaIds.Remove(ideaId);
            NotificationService.ShowError($"Error starting idea: {ex.Message}");
        }
    }

    private async Task ExpandIdea(Guid ideaId)
    {
        try
        {
            var result = await IdeaService.ExpandIdeaAsync(ideaId);
            if (result != null)
            {
                await LoadIdeas();
                if (result.ExpansionStatus == IdeaExpansionStatus.PendingReview)
                {
                    NotificationService.ShowSuccess("Idea expanded successfully. Review the specification.", "AI Expansion Complete");
                }
                else if (result.ExpansionStatus == IdeaExpansionStatus.Failed)
                {
                    NotificationService.ShowError(result.ExpansionError ?? "Expansion failed", "AI Expansion Failed");
                }
            }
        }
        catch (Exception ex)
        {
            NotificationService.ShowError($"Error expanding idea: {ex.Message}");
        }
    }

    private async Task ApproveIdeaExpansion((Guid ideaId, string? editedDescription) args)
    {
        try
        {
            var result = await IdeaService.ApproveExpansionAsync(args.ideaId, args.editedDescription);
            if (result != null)
            {
                await LoadIdeas();
                NotificationService.ShowSuccess("Specification approved. The idea is ready to run.", "Expansion Approved");
            }
        }
        catch (Exception ex)
        {
            NotificationService.ShowError($"Error approving expansion: {ex.Message}");
        }
    }

    private async Task RejectIdeaExpansion(Guid ideaId)
    {
        try
        {
            await IdeaService.RejectExpansionAsync(ideaId);
            await LoadIdeas();
            NotificationService.ShowInfo("Expansion discarded. You can try again or edit manually.", "Expansion Discarded");
        }
        catch (Exception ex)
        {
            NotificationService.ShowError($"Error rejecting expansion: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Cancel any pending SignalR connection attempts
        _signalRCts?.Cancel();
        _signalRCts?.Dispose();

        _refreshTimer?.Dispose();

        if (_hubConnection != null)
        {
            try
            {
                if (_hubConnection.State == HubConnectionState.Connected)
                {
                    await _hubConnection.InvokeAsync("UnsubscribeFromProject", ProjectId.ToString());
                    await _hubConnection.InvokeAsync("UnsubscribeFromJobList");
                }
                await _hubConnection.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }
}